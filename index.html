<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Embedded Systems Quiz Practice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .tabs {
            display: flex;
            background: #f5f5f5;
            overflow-x: auto;
            border-bottom: 2px solid #ddd;
        }

        .tab {
            padding: 15px 25px;
            cursor: pointer;
            background: #f5f5f5;
            border: none;
            font-size: 14px;
            font-weight: 500;
            color: #555;
            transition: all 0.3s;
            white-space: nowrap;
            border-bottom: 3px solid transparent;
        }

        .tab:hover {
            background: #e8e8e8;
            color: #333;
        }

        .tab.active {
            background: white;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .content {
            padding: 30px;
            min-height: 400px;
        }

        .quiz-mode {
            display: none;
        }

        .quiz-mode.active {
            display: block;
        }

        .question-card {
            background: #f9f9f9;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .question-number {
            background: #667eea;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        .question-text {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .options {
            margin-bottom: 15px;
        }

        .option {
            background: white;
            padding: 12px 15px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #e0e0e0;
        }

        .option:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .option.selected {
            border-color: #667eea;
            background: #e8eeff;
        }

        .option.correct {
            border-color: #4caf50;
            background: #e8f5e9;
        }

        .option.incorrect {
            border-color: #f44336;
            background: #ffebee;
        }

        .answer-section {
            margin-top: 15px;
            padding: 15px;
            background: #e0f7fa;
            border-radius: 8px;
            border-left: 4px solid #26c6da;
            display: none;
        }

        .answer-section.show {
            display: block;
        }

        .answer-label {
            font-weight: bold;
            color: #00796b;
            margin-bottom: 8px;
        }

        .explanation {
            color: #555;
            font-style: italic;
            margin-top: 10px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #555;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-shuffle {
            background: #ff9800;
            color: white;
        }

        .btn-shuffle:hover {
            background: #f57c00;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .score-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            margin-bottom: 25px;
            font-size: 18px;
            font-weight: bold;
        }

        .welcome-message {
            text-align: center;
            padding: 40px;
            color: #555;
        }

        .welcome-message h2 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .welcome-message p {
            line-height: 1.8;
            margin-bottom: 10px;
        }
        .fill-inputs {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 12px 0 6px;
        }
        .fill-input {
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            min-width: 140px;
            font-size: 14px;
        }
        .fill-input.correct {
            border-color: #4caf50;
            background: #e8f5e9;
        }
        .fill-input.incorrect {
            border-color: #f44336;
            background: #ffebee;
        }
        @media (max-width: 768px) {
            .tabs {
                flex-wrap: wrap;
            }
            
            .tab {
                flex: 1 1 auto;
                min-width: 120px;
            }
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ“ Embedded Systems Quiz Practice</h1>
            <p>Master your knowledge topic by topic</p>
        </div>

        <div class="tabs" id="tabsContainer">
            <button class="tab active" data-topic="welcome">Home</button>
            <button class="tab" data-topic="all">All Topics</button>
            <button class="tab" data-topic="intro">Introduction to Embedded</button>
            <button class="tab" data-topic="c">Embedded C</button>
            <button class="tab" data-topic="gpio">GPIO</button>
            <button class="tab" data-topic="digital">Digital Communication</button>
            <button class="tab" data-topic="interrupts">Interrupts</button>
            <button class="tab" data-topic="timers">Timers & PWM</button>
            <button class="tab" data-topic="adc">ADC</button>
            <button class="tab" data-topic="os">Embedded OS</button>
            <button class="tab" data-topic="testing">Testing</button>
            <button class="tab" data-topic="optimise">Optimise</button>
            <button class="tab" data-topic="sensor">Sensor Fusion</button>
        </div>

        <div class="content" id="content">
            <div class="quiz-mode active" id="welcome">
                <div class="welcome-message">
                    <h2>Welcome to Your Quiz Practice System!</h2>
                    <p>ðŸ“š Select a topic from the tabs above to start practicing.</p>
                    <p>âœ… Choose "All Topics" for a comprehensive test covering everything.</p>
                    <p>ðŸŽ¯ Track your progress and review explanations for each question.</p>
                    <p>ðŸ”€ Use the Shuffle button to randomize questions and answer options!</p>
                    <p><strong>Current Question Bank:</strong> Introduction to Embedded (17) + Embedded C (18) + GPIO (16) + Digital Communication (11) + Interrupts (13) + Timer and PWM (8) + ADC (9) + Embedded OS (10) + Testing (20) + Optimise (9) + Sensor Fusion (9) = TOTAL (140)</p>
                </div>
            </div>

            <div class="quiz-mode" id="all"></div>
            <div class="quiz-mode" id="intro"></div>
            <div class="quiz-mode" id="c"></div>
            <div class="quiz-mode" id="gpio"></div>
            <div class="quiz-mode" id="digital"></div>
            <div class="quiz-mode" id="interrupts">
                <div class="welcome-message">
                    <h2>Interrupts Questions Coming Soon</h2>
                    <p>Add your Interrupts questions to populate this section.</p>
                </div>
            </div>
            <div class="quiz-mode" id="timers">
                <div class="welcome-message">
                    <h2>Timers & PWM Questions Coming Soon</h2>
                    <p>Add your Timers & PWM questions to populate this section.</p>
                </div>
            </div>
            <div class="quiz-mode" id="adc">
                <div class="welcome-message">
                    <h2>ADC Questions Coming Soon</h2>
                    <p>Add your ADC questions to populate this section.</p>
                </div>
            </div>
            <div class="quiz-mode" id="os"></div>
            <div class="quiz-mode" id="testing"></div>
            <div class="quiz-mode" id="optimise"></div>
            <div class="quiz-mode" id="sensor"></div>
        </div>
    </div>

    <script>
        const questions = {
            intro: [
                {
                    question: "Which of the following is true about 'hard real-time constraints'?",
                    options: ["A late response can degrade a system.", "Tasks have no deadlines.", "Missed deadline can have extreme consequences.", "Typically non-critical systems."],
                    correct: 2,
                    explanation: "Hard real-time constraints imply that missing a deadline can result in severe system failures or extreme consequences."
                },
                {
                    question: "Which best describes the pattern that any embedded system should follow?",
                    options: ["input-process-output", "process-output-input", "input-output-process", "process-input-output"],
                    correct: 0,
                    explanation: "The standard flow for embedded systems is input data, process it, and then output the result."
                },
                {
                    question: "Which of the following properties of embedded systems are true? (Select all that apply)",
                    options: ["Microcontrollers are typically used rather than microprocessors", "Dedication to a wide range of tasks", "Utilization of high memory and computing power", "Necessity for strict timing constraints"],
                    correct: [0, 3],
                    explanation: "Embedded systems typically use microcontrollers and often require strict timing constraints to operate correctly.",
                    multipleCorrect: true
                },
                {
                    question: "Which of the following best defines an Embedded System (ES)?",
                    options: ["A standalone software application.", "A system that only uses analogue electronics.", "A general-purpose computer for various tasks.", "A computing system dedicated to a specific task within a larger electrical system."],
                    correct: 3,
                    explanation: "An embedded system is designed for a specific task, typically part of a larger system, often with real-time constraints."
                },
                {
                    question: "An Assembler ...",
                    options: ["is also called a Compiler", "optimizes the source code.", "translates an assembly source file into an object file", "does a one-to-one with a compiler"],
                    correct: 2,
                    explanation: "An assembler converts assembly language code into machine code or an object file, but it doesn't optimize the code like a compiler."
                },
                {
                    question: "Choose the programming language that is the lowest level.",
                    options: ["C", "Fortran", "Object", "Assembly"],
                    correct: 3,
                    explanation: "Assembly is a low-level programming language that directly corresponds to machine code instructions."
                },
                {
                    question: "What type of real-time constraint describes a system where missing deadlines can have catastrophic consequences (e.g., an airbag controller)?",
                    options: ["Soft real-time", "Adaptive real-time", "Non real-time", "Hard real-time"],
                    correct: 3,
                    explanation: "Hard real-time systems have strict deadlines, and missing these deadlines can have catastrophic consequences."
                },
                {
                    question: "Based on the lecture, which file(s) can be converted to an object file? (Select all that apply)",
                    options: ["C file", "Decoded file", "Hex file", "Assembly file"],
                    correct: [0, 3],
                    explanation: "Both C and Assembly source files can be compiled into object files.",
                    multipleCorrect: true
                },
                {
                    question: "Which is/are the typical product development process?",
                    options: ["Testing", "Deployment", "Implementation", "All of the above"],
                    correct: 3,
                    explanation: "Product development typically includes testing, deployment, and implementation phases."
                },
                {
                    question: "Which one is an intermediate file produced by the compiler?",
                    options: ["Binary file", "Objective file", "Objection file", "Object file"],
                    correct: 3,
                    explanation: "The object file is an intermediate file produced by the compiler before linking to generate the final executable."
                },
                {
                    question: "The Linker ...",
                    options: ["Executes a file", "Combines one or more object files into a single executable file", "Loads the executable file to the memory for execution", "Archives the data files into a single executable file"],
                    correct: 1,
                    explanation: "The linker combines object files into an executable file, resolving external references between them."
                },
                {
                    question: "A Compiler ...",
                    options: ["Arranges all the '.c' files in the folder", "Translates source codes in 'C' language into an executable file.", "Translates source codes in 'C' language into object files", "Is also called an Assembler."],
                    correct: 2,
                    explanation: "The compiler translates the source code (in C) into object files, which are then linked to create an executable."
                },
                {
                    question: "Which is the main characteristic of low-level language?",
                    options: ["Do not need a compiler/assembler", "Very easy to understand", "Compact and optimized", "Productivity"],
                    correct: 2,
                    explanation: "Low-level languages are typically more compact and optimized for direct hardware control, but they are harder to understand."
                },
                {
                    question: "Which of the following are properties of Embedded Systems? (Select all that apply)",
                    options: ["They are dedicated to handle specific tasks.", "They interact with the real world using sensors and actuators.", "They use abundant resources compared to general-purpose computers.", "They often have strict timing constraints."],
                    correct: [0, 1, 3],
                    explanation: "Embedded systems are task-specific, interact with the physical world, and often have strict timing and resource constraints.",
                    multipleCorrect: true
                },
                {
                    question: "Which of these are properties of embedded systems? (Select all that apply)",
                    options: ["Unlimited processing power", "Able to handle certain timing constraints", "Based on microcontrollers", "Infinite memory"],
                    correct: [1, 2],
                    explanation: "Embedded systems often use microcontrollers and handle timing constraints, but they have limited resources, including processing power and memory.",
                    multipleCorrect: true
                },
                {
                    question: "What is a 'Heisenbug' as described in the context of the Therac-25 case study?",
                    options: ["A bug that disappears or changes behavior when observed or debugged.", "A bug related to network communication.", "A bug that explodes", "A bug that is easy to reproduce and fix.", "A bug caused by hardware malfunction."],
                    correct: 0,
                    explanation: "A Heisenbug is a type of bug that seems to disappear or behave differently when the program is being debugged or observed."
                },
                {
                    question: "A startup code typically (Select all that apply)",
                    options: ["Initialize the Stack", "Reset all the memory", "Initialize the Heap", "Calls the main function", "Return to the main function"],
                    correct: [0, 2, 3],
                    explanation: "Startup code usually sets up the environment, initializes hardware, and then calls the main function to start the program's execution.",
                    multipleCorrect: true
                }
            ],
            c: [
                {
                    question: "~0xEEE0 = ?",
                    options: ["0x111F", "0xEEE0", "0x0", "0xFFFF"],
                    correct: 0,
                    explanation: "The tilde (~) operator is a bitwise NOT operation. The bitwise negation of 0xEEE0 results in 0x111F."
                },
                {
                    question: "What does the term 'Data Type' primarily refer to in C programming?",
                    options: ["The name of a variable", "The type of data a variable can hold", "The memory address of a variable", "The size of a variable"],
                    correct: 1,
                    explanation: "In C programming, the 'Data Type' refers to the kind of data a variable can store, such as integer, float, char, etc."
                },
                {
                    question: "17 && 23 = ?",
                    options: ["0", "1", "17", "23"],
                    correct: 1,
                    explanation: "The && operator is the logical AND operator. Since both 17 and 23 are non-zero, the result is true, which is represented as 1."
                },
                {
                    question: "The operator (!) is used for Bitwise Complement (Negation)?",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "The operator ! is used for logical negation, not bitwise negation. The correct operator for bitwise negation is ~."
                },
                {
                    question: "Which of the following is False?",
                    options: ["Addition (+)", "Modulo (%)", "Division (/)", "Exponentiation (^)"],
                    correct: 3,
                    explanation: "In C, the caret (^) is NOT an exponentiation operatorâ€”it's the bitwise XOR operator. C does not have a built-in exponentiation operator; use pow() from math.h instead."
                },
                {
                    question: "How many different bitwise operators are there? (Assume it's for Pico C SDK)",
                    options: ["2", "3", "4", "5", "6"],
                    correct: 4,
                    explanation: "There are 6 bitwise operators in C: & (AND), | (OR), ^ (XOR), ~ (NOT), << (Left Shift), >> (Right Shift)."
                },
                {
                    question: "In C, what numeric value represents TRUE in a conditional expression? (Select all that apply)",
                    options: ["-1", "1", "Any non-zero value", "0"],
                    correct: [0, 1, 2],
                    explanation: "In C, any non-zero value is treated as TRUE. While comparison operations conventionally return 1 for TRUE, values like -1 or any other non-zero number are also evaluated as TRUE in conditional expressions.",
                    multipleCorrect: true
                },
                {
                    question: "Which type of variable retains its value between function calls and is stored in RAM?",
                    options: ["Static variable", "Local variable", "Global variable", "Register variable"],
                    correct: 0,
                    explanation: "Static variables retain their values between function calls and are stored in RAM."
                },
                {
                    question: "Which operator is used to find the remainder of an integer division?",
                    options: ["/", "-", "%", "^", "+", "*"],
                    correct: 2,
                    explanation: "The modulo operator (%) is used to find the remainder of an integer division."
                },
                {
                    question: "How many bytes of memory does a char data type typically require in most C compilers?",
                    options: ["2 bytes", "4 bytes", "1 byte", "8 bytes"],
                    correct: 2,
                    explanation: "In most C compilers, a char data type typically requires 1 byte of memory."
                },
                {
                    question: "When monitoring a specific bit, for example, bit 5 of register P0, what expression creates a mask to target that bit?",
                    options: ["(P0 & 5)", "(P0 | 5)", "(5 << 1)", "(1 << 5)"],
                    correct: 3,
                    explanation: "The bit shift operation (1 << 5) creates a mask with only bit 5 set to 1, creating the binary pattern 00100000 to target bit 5 of register P0."
                },
                {
                    question: "Performing a left shift operation on a number by N bits is equivalent to what arithmetic operation?",
                    options: ["Dividing the number by 2 to the power of N", "Multiplying the number by 2 to the power of N", "Adding N to the number", "Subtracting N from the number"],
                    correct: 1,
                    explanation: "A left shift operation by N bits is equivalent to multiplying the number by 2^N."
                },
                {
                    question: "To extract the upper 8 bits from a 16-bit data, what is the first recommended operation?",
                    options: ["Left shift by 8 bits", "Logical AND with 0xFF00", "Bitwise OR with 0x00FF", "Right shift by 8 bits"],
                    correct: 3,
                    explanation: "Right shifting by 8 bits (data >> 8) directly moves the upper 8 bits down to the lower byte position in one operation, making them immediately usable. While AND with 0xFF00 isolates the upper bits, they remain in the upper position and still require a right shift afterward."
                },
                {
                    question: "What is the typical size of a short int data type?",
                    options: ["1 byte", "2 bytes", "4 bytes", "8 bytes"],
                    correct: 1,
                    explanation: "The typical size of a short int data type is 2 bytes (16 bits) in most compilers."
                },
                {
                    question: "Which data type is usually 4 bytes and primarily used for measuring things like weight, distance, or temperature on a Pico W?",
                    options: ["long double", "char", "float", "double", "int"],
                    correct: 2,
                    explanation: "The float data type is typically 4 bytes and is specifically designed for measurements such as weight, distance, and temperature that require decimal precision."
                },
                {
                    question: "If a register contains 0x06 and a left shift operation is performed by 1 position (0x06 << 1), what is the expected result?",
                    options: ["0x03", "0x0C", "0x07", "0x0E"],
                    correct: 1,
                    explanation: "A left shift operation on 0x06 (binary: 0000 0110) by 1 bit results in 0x0C (binary: 0000 1100). This is equivalent to multiplying 6 by 2, which equals 12 (0x0C)."
                },
                {
                    question: "Match the operators: & (A), || (B), | (C), && (D) with: Bitwise AND (1), Bitwise OR (2), Logical AND (3), Logical OR (4)",
                    options: ["Aâ†’1, Bâ†’4, Câ†’2, Dâ†’3", "Aâ†’2, Bâ†’3, Câ†’1, Dâ†’4", "Aâ†’3, Bâ†’1, Câ†’4, Dâ†’2", "Aâ†’4, Bâ†’2, Câ†’3, Dâ†’1"],
                    correct: 0,
                    explanation: "The & and | are bitwise operators, while && and || are logical operators. Correct matching: & (Bitwise AND), || (Logical OR), | (Bitwise OR), && (Logical AND)."
                },
                {
                    question: "If you declare an array int arr[5], what is the index of the last element?",
                    options: ["0", "1", "2", "3", "4", "5"],
                    correct: 4,
                    explanation: "In C, array indexing starts at 0. So for an array of size 5, the indices are 0, 1, 2, 3, 4, and the last index is 4."
                }
            ],
            gpio: [
                {
                    question: "In microcontrollers, GPIO stands for",
                    options: ["Global Public Input/Output", "Global Purpose Input/Output", "General Purpose Input/Output", "General Public Input/Output"],
                    correct: 2,
                    explanation: "GPIO stands for General Purpose Input/Output - pins that can be configured for various digital input or output functions."
                },
                {
                    question: "Regarding the direction of a General Purpose Input/Output (GPIO) pin, which statement is true?",
                    options: ["Pins can be changed between input and output modes, but not simultaneously", "A single GPIO pin can simultaneously be configured as both an input and an output", "Input and output operations always occur on separate, dedicated pins", "A GPIO pin must be permanently set as either input or output during manufacturing"],
                    correct: 0,
                    explanation: "GPIO pins can be dynamically reconfigured between input and output modes via software, but at any given moment they operate in only one mode."
                },
                {
                    question: "A multiplex matrix is used to connect buttons to a microcontroller because",
                    options: ["It is a safe way to debounce input signals", "It allows LEDs to display when a key is pressed", "The layout of the QWERTY keys means you must use a matrix", "It saves on the number of pins needed"],
                    correct: 3,
                    explanation: "A multiplex matrix significantly reduces the number of GPIO pins required. For example, a 4Ã—4 matrix needs only 8 pins instead of 16 individual pins."
                },
                {
                    question: "Most microcontrollers multiplex their GPIO pins with other functions",
                    options: ["True", "False"],
                    correct: 0,
                    explanation: "True. Most microcontrollers multiplex GPIO pins to allow them to serve different functions (like UART, SPI, I2C, PWM) under software control, maximizing pin utility."
                },
                {
                    question: "GPIO pins can support which of the following (without additional components):",
                    options: ["Digital input and output", "Analogue input and digital output", "Analogue output only", "Analogue and digital input and output"],
                    correct: 0,
                    explanation: "GPIO pins inherently support digital input and output. Analogue operations require additional components like ADC (Analog-to-Digital Converter) or DAC (Digital-to-Analog Converter)."
                },
                {
                    question: "How is the specific function of a multiplexed pin typically selected on a microcontroller?",
                    options: ["It is hard-wired during manufacturing and cannot be changed", "Automatically by the microcontroller based on the connected external device", "Through software configuration, such as writing to function select registers", "By physically rewiring the pin to a different internal circuit"],
                    correct: 2,
                    explanation: "Pin functions are selected via software configuration by writing to special function select registers, allowing flexibility without hardware changes."
                },
                {
                    question: "GPIO can be used to implement an SPI bus",
                    options: ["True", "False"],
                    correct: 0,
                    explanation: "True. While dedicated SPI hardware is more efficient, you can implement SPI communication using GPIO pins through bit-banging techniques."
                },
                {
                    question: "17 && 0 = ?",
                    options: ["1", "-17", "FALSE", "TRUE", "0", "17"],
                    correct: [2, 4],
                    explanation: "The && operator is logical AND. Since 0 is false, the result is false, which can be represented as either 0 or FALSE.",
                    multipleCorrect: true
                },
                {
                    question: "GPIO pins can support which of the following (without additional components):",
                    options: ["Digital input and output", "Analogue input and digital output", "Analogue output only", "Analogue and digital input and output"],
                    correct: 0,
                    explanation: "GPIO pins natively support digital input and output operations. Analogue capabilities require additional hardware components."
                },
                {
                    question: "In which circumstance would it be better to NOT use GPIO pins to communicate with a peripheral:",
                    options: ["When the peripheral is read-only, and you can't write to it", "When the peripheral specifies a very unusual custom interfacing protocol", "When the peripheral is a long distance away", "When you can use a built-in bus like I2C or SPI"],
                    correct: 3,
                    explanation: "Built-in communication buses like I2C or SPI are optimized for peripheral communication and should be preferred over bit-banging with GPIO for better performance and reliability."
                },
                {
                    question: "GPIO pins always need to be used with an external resistor",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "False. Many microcontrollers have built-in pull-up or pull-down resistors that can be enabled via software, eliminating the need for external resistors in many cases."
                },
                {
                    question: "The internal memory map of a microcontroller tells the programmer",
                    options: ["The location of registers in memory", "When the programmer can save and load files from", "The current amount of free RAM space in the device", "How to get a signal from an input pin to an output pin"],
                    correct: 0,
                    explanation: "The memory map shows where registers, peripherals, RAM, and ROM are located in the microcontroller's address space, essential for programming hardware."
                },
                {
                    question: "Which of the following communication bus tells an internal module to read or to write?",
                    options: ["Data bus", "Control bus", "Address bus", "CPU bus"],
                    correct: 1,
                    explanation: "The control bus carries control signals like read/write commands that tell modules whether to read from or write to memory or peripherals."
                },
                {
                    question: "Why do modern microcontrollers often have \"multiplexed\" or \"multi-function\" pins?",
                    options: ["To reduce power consumption by sharing tasks across multiple processors", "To increase the overall clock speed of the microcontroller", "To efficiently utilize a limited number of physical pins by allowing them to serve different functions under software control", "To provide a redundant set of pins in case of hardware failure"],
                    correct: 2,
                    explanation: "Pin multiplexing allows efficient use of limited physical pins by enabling software-configurable functions, maximizing versatility in compact packages."
                },
                {
                    question: "17 && 23 = ?",
                    options: ["FALSE", "TRUE", "6", "0", "40", "1"],
                    correct: [1, 5],
                    explanation: "The && operator is logical AND. Both 17 and 23 are non-zero (true), so the result is true, which can be represented as either 1 or TRUE.",
                    multipleCorrect: true
                },
                {
                    question: "An 8-bit GPIO port must be configured to have all 8 pins as \"all output\" or \"all input\"",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "False. GPIO ports typically allow individual pin configuration, so you can mix inputs and outputs within the same 8-bit port."
                }
            ],
            digital: [
                {
                    question: "Using a single parity bit when transmitting a 7-bit character over EIA/RS-232, you can",
                    options: ["Indicate to the transmitter that it must re-send the character", "Detect when 1 or 3 bits are received in error", "Detect when 2 or 4 bits are received in error", "Correct an error of 1 bit in the received character"],
                    correct: 1,
                    explanation: "A single parity bit can detect an odd number of bit errors (1 or 3 bits). It cannot detect an even number of errors (2 or 4 bits) as they cancel out, and it cannot correct errors."
                },
                {
                    question: "An SPI master can only have one slave",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "False. An SPI master can have multiple slaves. Each slave is selected using a separate chip select (CS) line."
                },
                {
                    question: "We need to provide slave address for UART communication protocol.",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "False. UART is a point-to-point communication protocol that doesn't use addressing. It's typically used for direct communication between two devices."
                },
                {
                    question: "Which digital communication protocol is asynchronous?",
                    options: ["UART", "SPI", "I2C", "All of them."],
                    correct: 0,
                    explanation: "UART is asynchronous - it doesn't use a shared clock signal. SPI and I2C are synchronous protocols that use a clock line."
                },
                {
                    question: "Half-duplex transmission between unit A and unit B is where",
                    options: ["Units A and B transmit at the same time", "Units A and B take turns to transmit", "Only Unit A can transmit, Unit B can only receive", "Unit A sends half of the data, then unit B sends the other half"],
                    correct: 1,
                    explanation: "Half-duplex means both devices can transmit and receive, but not simultaneously - they take turns. Full-duplex allows simultaneous bidirectional communication."
                },
                {
                    question: "The I2C protocol has separate wires for transmit and receive (called MOSI and MISO)",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "False. MOSI and MISO are SPI signal names. I2C uses a single bidirectional data line (SDA) along with a clock line (SCL)."
                },
                {
                    question: "A 7-bit ascii data is transmitted with 1 start bit, 1 stop bit and 1 parity bit at a baud rate of 9600. How fast is the 7-bit ascii data being transmitted?",
                    options: ["1.146 ms", "0.104 ms", "0.115 ms", "1.042 ms"],
                    correct: 3,
                    explanation: "Total bits per character = 1 start + 7 data + 1 parity + 1 stop = 10 bits. Time = 10 bits / 9600 baud = 0.001042 seconds = 1.042 ms."
                },
                {
                    question: "In EIA/RS-232, what indicates that a character is about to be transmitted",
                    options: ["The header is transmitted first", "The chip select (CS) line", "Transmit indicator wire", "A start bit"],
                    correct: 3,
                    explanation: "In UART/RS-232, a start bit (typically a transition from idle high to low) indicates the beginning of a character transmission."
                },
                {
                    question: "A synchronous communications link has a separate clock wire",
                    options: ["True", "False"],
                    correct: 0,
                    explanation: "True. Synchronous protocols like SPI and I2C use a dedicated clock line to synchronize data transmission between devices."
                },
                {
                    question: "How is data transmitted onto the serial console?",
                    options: ["One byte at a time", "One sentence at a time", "One string at a time", "One word at a time"],
                    correct: 0,
                    explanation: "Serial communication transmits data one byte (character) at a time. Higher-level data like strings are broken down into individual bytes for transmission."
                },
                {
                    question: "We need to provide slave address for UART communication protocol.",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "False. UART doesn't use addressing as it's a point-to-point protocol. Protocols like I2C require slave addresses for multi-device communication."
                }
            ],
            interrupts: [
                {
                    question: "Level-triggered interrupts can be falling or rising edge.",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "False. Level-triggered interrupts respond to a constant logic level (high or low), while edge-triggered interrupts react to rising/falling transitions."
                },
                {
                    // FILL-IN-THE-BLANK VERSION
                    type: "fill",
                    question: "A CPU can ________________ data onto a stack and later it must ____________________ it off again.",
                    answers: ["push", "pop"], // order matters
                    explanation: "The correct terms are push (to place data on the stack) and pop (to remove it)."
                },
                {
                    question: "Why should you clear the interrupt flag before exiting an ISR?",
                    options: [
                        "To prevent the ISR immediately re-running",
                        "Because ISRs cannot use global variables",
                        "To tell the user the code has ended",
                        "To tidy up the stack before you leave"
                    ],
                    correct: 0,
                    explanation: "If the interrupt flag is not cleared, the CPU will see the interrupt still pending and re-enter the ISR repeatedly."
                },
                {
                    question: "What is the purpose of the interrupt vector table (IVT)?",
                    options: [
                        "To store the code that causes interrupts to happen",
                        "To hold the address of ISRs which can handle interrupts",
                        "To store code that prevents interrupts",
                        "To store the actual ISR functions"
                    ],
                    correct: 1,
                    explanation: "The IVT stores pointers to the ISRs, not the code itself."
                },
                {
                    question: "An interrupt is always a bad thing for a CPU.",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "Interrupts allow the CPU to respond quickly to events. They are essential for real-time systems."
                },
                {
                    question: "Inside a microprocessor, a 'timer' is:",
                    options: [
                        "An ISR triggered by the RTC",
                        "Software that implements a stopwatch function",
                        "A counter that can run down or up",
                        "A built-in clock unit"
                    ],
                    correct: 2,
                    explanation: "Timers are hardware counters driven by a clock source."
                },
                {
                    question: "ISR code should ideally be:",
                    options: [
                        "written with a proper user interface",
                        "only executed at boot time",
                        "small and efficient",
                        "written in a high-level language"
                    ],
                    correct: 2,
                    explanation: "ISRs should run quickly to avoid blocking other processes."
                },
                {
                    question: "An RTC crystal or oscillator allows a CPU to:",
                    options: [
                        "Connect to peripherals that also have an RTC",
                        "Generate its main system clock",
                        "Improve the timing of its ISRs",
                        "Provide a signal that can be exactly divided into 1 second"
                    ],
                    correct: 3,
                    explanation: "A 32.768 kHz crystal divides cleanly into 1 second."
                },
                {
                    question: "Interrupts are usually really simple to debug.",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "Interrupts execute asynchronously, making debugging more complex."
                },
                {
                    question: "The SP (Stack Pointer) is:",
                    options: [
                        "A variable that contains temporary data",
                        "A register that indicates the end of the stack",
                        "A placeholder to remember stack memory",
                        "The stack push indicator"
                    ],
                    correct: 1,
                    explanation: "The stack pointer register holds the address of the current top of the stack."
                },
                {
                    question: "The watchdog timer (WDT) is designed to restart a system if the software crashes.",
                    options: ["True", "False"],
                    correct: 0,
                    explanation: "If not periodically reset ('kicked'), the watchdog forces a reboot."
                },
                {
                    question: "If events occur very frequently with very short intervals, the best method is:",
                    options: ["Polling", "Interrupts", "Nested Interrupts", "Masking"],
                    correct: 1,
                    explanation: "Interrupts allow immediate response, avoiding missed events."
                },
                {
                    question: "In the lecture, we defined the utilisation for an interrupt as u = (h+c)/T. In general, utilisation is the percentage of time when the processor is busy and h is the timing overhead for handling the interrupt. Suppose the inter-arrival time between two events is 500 cycles and the processor needs 18 cycles for either a pop or a push. For an ISR which requires 20 cycles for completion, what is its utilisation?",
                    options: ["11.2", "7.6", "11.6", "4"],
                    correct: 0,
                    explanation: "T=500 cycles (inter-arrival time), Push cost = 18 cycles, Pop cost = 18 cycles, overhead (h) = 36, execution time (c) = 20, so u=(36+20)/500=0.112=11.2%."
                }
            ],
            timers: [
                {
                    question: "An RTC crystal or oscillator allows a CPU to:",
                    options: [
                        "connect to peripherals that also have an RTC",
                        "improve the timing of its ISRs",
                        "directly drive its main system clock",
                        "provide a signal that can be exactly divided into 1 second"
                    ],
                    correct: 3,
                    explanation: "RTCs use a precise crystal (commonly 32.768 kHz) that divides cleanly down to 1 Hz, allowing accurate timekeeping independent of the main system clock."
                },
                {
                    question: "Inside a microcontroller, a 'timer' is a/an:",
                    options: [
                        "software that implements a stopwatch function",
                        "built-in clock unit",
                        "ISR triggered by the RTC",
                        "counter that can run down or up"
                    ],
                    correct: 3,
                    explanation: "A timer module is a hardware counter. It increments or decrements based on the input clock and can trigger interrupts or events when reaching limits."
                },
                {
                    type: "fill",
                    image: "pwn_signal.png",
                    question: "'A' must be __________ to make a 40% duty-cycle, if 'B' is 30 ms. (include units)",
                    answers: ["75ms"],
                    explanation: "Duty Cycle = B/A â†’ A = B / 0.4 = 30 ms / 0.4 = 75 ms."
                },
                {
                    type: "fill",
                    question: "A __________ count is used to obtain a 1 second timer from a 30 MHz clock.",
                    answers: ["30000000"],
                    explanation: "Count = Frequency Ã— Time = 30,000,000 Ã— 1 = 30,000,000."
                },
                {
                    question: "The watchdog timer (WDT) is designed to restart a system if the software crashes.",
                    options: ["True", "False"],
                    correct: 0,
                    explanation: "If the software stops refreshing ('kicking') the watchdog, the WDT resets the MCU to recover from lock-ups."
                },
                {
                    question: "Given the behaviour: (1) Counter wraps around to the maximum after reaching zero, (2) A flag is set when it wraps. Timer_32 is operating in:",
                    image: "free_running_timer.png",
                    options: [
                        "Periodic Timer Mode",
                        "Continuous Mode",
                        "Free Running Mode",
                        "One-shot Mode"
                    ],
                    correct: 2,
                    explanation: "Free Running Mode allows the timer to continuously roll over without stopping or reloading externally."
                },
                {
                    question: "A 1 Hz clock is:",
                    options: [
                        "used by the Real Time Clock",
                        "generated using a counter that counts till 2^15",
                        "directly used as the main clock",
                        "generated using a crystal that emits a signal at 32.768 kHz"
                    ],
                    correct: [0,1,3], // multiple correct answers supported
                    explanation: "A 32.768 kHz crystal divides cleanly by 2^15 to produce a 1 Hz tick, which is used by the RTC.",
                    multipleCorrect: true
                },
                {
                    question: "The count-down timer free-running mode means:",
                    options: [
                        "Counter wraps back around to 0 after hitting a maximum value",
                        "Counter counts down to 0 then begins counting up",
                        "Counter wraps back around to maximum after counting down to 0",
                        "Counter counts down from maximum to 0 and then stops automatically"
                    ],
                    correct: 2,
                    explanation: "Free-running countdown timers automatically reload the maximum value when they reach zero and continue running indefinitely."
                }
            ],
            os: [
                {
                    question: "Task functions typically do not call 'return()'",
                    options: ["True", "False"],
                    correct: 0,
                    explanation: "True. In an RTOS, task functions are designed to loop indefinitely using for(;;) instead of returning. Returning from a task would cause it to be deleted by the scheduler."
                },
                {
                    question: "A task is the smallest sequence of instructions that can be managed independently by an/a ....",
                    options: ["interrupt", "inter-process communication (IPC)", "task control block (TCB)", "scheduler"],
                    correct: 3,
                    explanation: "A task is the smallest executable unit managed independently by the scheduler. The TCB stores task metadata, but the scheduler handles task execution order."
                },
                {
                    question: "Which Task State occurs the least amount of time?",
                    options: ["Ready", "Terminated", "Running", "Blocked"],
                    correct: 1,
                    explanation: "The Terminated state occurs for the least amount of time because a task only enters this state once when it finishes or is explicitly deleted. After that, it is removed from memory."
                },
                {
                    question: "Which of these characteristics of Monolithic Kernel is false?",
                    options: [
                        "Hard to extend its functionality",
                        "Both user services and kernel services are kept in the same address space",
                        "Fast Execution",
                        "A service crash does not crash the whole system"
                    ],
                    correct: 3,
                    explanation: "In a Monolithic Kernel, all services share the same address space. Therefore, if one service crashes, the entire system is affected â€” making this statement false."
                },
                {
                    question: "Which of the following are considerations when selecting an RTOS? (Select 2)",
                    options: ["Features", "Machine Learning", "Debuggers", "Decompilers"],
                    correct: [0, 2],
                    explanation: "When selecting an RTOS, developers evaluate available kernel features and debugging support. Machine learning and decompilers are unrelated factors.",
                    multipleCorrect: true
                },
                {
                    question: "Which service/feature is the most important for multi-tasking to work in an EOS?",
                    options: ["polling", "memory management", "context switch", "inter-process communication"],
                    correct: 2,
                    explanation: "Context switching is essential for multitasking. It allows multiple tasks to share a CPU by saving and restoring the task context when switching between them."
                },
                {
                    question: "If a task calls the following function, it will be placed into a 'blocked' state for 250ms: vTaskDelay(250);",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "False. vTaskDelay() delays a task for a number of ticks, not milliseconds. To delay for 250 ms, you must use vTaskDelay(pdMS_TO_TICKS(250));. Otherwise, the actual delay duration depends on the system tick rate."
                },
                {
                    question: "In FreeRTOS, the lowest priority interrupt (ISR) will interrupt the highest priority task.",
                    options: ["True", "False"],
                    correct: 0,
                    explanation: "False. Higher-priority interrupts preempt lower-priority ones. The lowest-priority ISR cannot interrupt a higher-priority task."
                },
                {
                    question: "Which of the following statement is true based on the following code snippet?\n\nxTaskCreate(avg_task, 'AvgThread', configMINIMAL_STACK_SIZE, NULL, TEST_TASK_PRIORITY, NULL);\nxTaskCreate(simpleaverage, 'TempThread', configMINIMAL_STACK_SIZE, NULL, TEST_TASK_PRIORITY, NULL);\nxTaskCreate(printfunction, 'AvgThread', configMINIMAL_STACK_SIZE, NULL, TEST_TASK_PRIORITY, &printtask);",
                    options: [
                        "The program will crash at the instruction: 'for( ; ; )'",
                        "Round-robin scheduling will occur",
                        "Priority-based scheduling will occur",
                        "The program will crash at the instruction: 'vTaskStartScheduler()'"
                    ],
                    correct: 1,
                    explanation: "All tasks are created with the same priority (TEST_TASK_PRIORITY). FreeRTOS performs round-robin scheduling among equal-priority tasks."
                },
                {
                    question: "Which Priority Driven Scheduling Algorithm is dynamic-priority based?",
                    options: [
                        "Rate Monotonic Scheduling (RMS)",
                        "Least Slack Time (LST)",
                        "Earliest Deadline First (EDF)",
                        "Deadline Monotonic Scheduling (DMS)"
                    ],
                    correct: [1, 2],
                    explanation: "Least Slack Time (LST) and Earliest Deadline First (EDF) are dynamic-priority algorithms. Their priorities change at runtime based on time constraints.",
                    multipleCorrect: true
                }
            ],
            optimise: [
                {
                    question: "Select the three main classification for optimization in embedded systems.",
                    options: ["Performance", "Compiler", "Power", "Memory"],
                    correct: [0, 2, 3],
                    explanation: "The three main optimization classifications in embedded systems are Performance, Power, and Memory. Compiler is a tool/technique used to achieve these optimizations, not a classification category itself.",
                    multipleCorrect: true
                },
                {
                    question: "Which of the following will be affected by different software?",
                    options: ["high clock frequency", "static leakage", "dynamic power consumption", "static power consumption"],
                    correct: 2,
                    explanation: "Software directly controls how and when the processor executes instructions, which impacts dynamic power consumption. Static power consumption and static leakage are primarily hardware characteristics not significantly affected by software."
                },
                {
                    question: "What is the immediate purpose of a shunt resistor?",
                    options: ["to measure power consumption", "to profile an application", "to measure voltage drop", "to measure current flow"],
                    correct: 2,
                    explanation: "The immediate purpose of a shunt resistor is to create a measurable voltage drop. The voltage drop is then used to calculate current using Ohm's law (I = V/R)."
                },
                {
                    question: "A 100% CPU utilisation will give a ________ power usage.",
                    options: ["typical", "average", "worst-case", "maximum"],
                    correct: 2,
                    explanation: "A 100% CPU utilization represents a worst-case power usage scenario where the processor is fully stressed and performing maximum work."
                },
                {
                    question: "Select two methods that helps in minimizing power consumption.",
                    options: ["loop unrolling", "application scaling", "voltage scaling", "clock scaling"],
                    correct: [2, 3],
                    explanation: "Voltage scaling and clock scaling form the basis of Dynamic Voltage and Frequency Scaling (DVFS), which is the primary method for reducing power consumption in embedded systems. Power scales quadratically with voltage and linearly with clock frequency.",
                    multipleCorrect: true
                },
                {
                    question: "Which of the following are optimization techniques for performance? (Select 4 correct answers)",
                    options: ["Functions calling conventions", "Hardware loops", "Assembly inlining", "Choosing the right data types"],
                    correct: [0, 1, 2, 3],
                    explanation: "All four are recognized performance optimization techniques: Function calling conventions minimize overhead, hardware loops reduce instruction counts, assembly inlining eliminates branching overhead, and choosing appropriate data types improves memory usage and cache performance.",
                    multipleCorrect: true
                },
                {
                    question: "Loop unrolling can work on dynamic number of iterations.",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "Loop unrolling requires the number of iterations to be known at compile time. It is a static optimization technique where the compiler replicates the loop body during compilation. Loops with runtime-determined iteration counts cannot be effectively unrolled."
                },
                {
                    question: "Floating point operations are encouraged in embedded systems.",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "Floating-point operations are typically slower and more power-consuming than integer calculations, especially in microcontrollers without a floating-point unit (FPU). They are generally discouraged unless absolutely necessary."
                },
                {
                    question: "A program running on a microcontroller without hardware multiplication support needs to compute X=AÃ—2+BÃ—C. Which of the following versions would likely execute the fastest? (Select all that apply)",
                    options: ["X = (A * 2) + (B * C)", "X = A + A + (B * C)", "X = (A * 2) + (C * B)", "X = (A + A) + (B * C)", "X = (A << 1) + (B * C)"],
                    correct: [1, 3, 4],
                    explanation: "The versions that avoid the 'A * 2' multiplication operation execute fastest. On microcontrollers without hardware multiplication, shift operations (A << 1) and addition operations (A + A) are single-cycle instructions, while multiplication requires many cycles using shift-and-add algorithms.",
                    multipleCorrect: true
                }
            ],
            testing: [
                {
                    question: "What is the purpose of boundary value analysis in embedded software testing?",
                    options: [
                        "To validate hardware components",
                        "To check how the system handles extreme inputs",
                        "To assess system security",
                        "To test the system's user interface"
                    ],
                    correct: 1,
                    explanation: "Boundary value analysis is a testing technique that focuses on testing at the boundaries or extreme edges of input values, as errors often occur at these boundary conditions in embedded systems."
                },
                {
                    question: "Boundary scan testing inside a microcontroller",
                    options: [
                        "Can intercept signals between CPU and external pins",
                        "Is a parallel, asynchronous test bus for the internal CPU",
                        "Only controls the state of the external pins",
                        "Controls the CPU alone"
                    ],
                    correct: 0,
                    explanation: "Boundary scan testing (using JTAG/IEEE 1149.1 standard) allows testing of interconnections between integrated circuits by inserting test logic that can intercept and control signals between the CPU and external pins."
                },
                {
                    question: "Which type of testing focuses on verifying the functionality of individual software modules or components?",
                    options: [
                        "Regression testing",
                        "Integration testing",
                        "Unit testing",
                        "System testing"
                    ],
                    correct: 2,
                    explanation: "Unit testing is a software testing method where individual units or components of software are tested in isolation to verify that each unit functions correctly on its own before integration with other components."
                },
                {
                    question: "Which testing phase involves testing the entire embedded system as a whole?",
                    options: [
                        "Unit testing",
                        "Performance testing",
                        "Integration testing",
                        "System testing"
                    ],
                    correct: 3,
                    explanation: "System testing is the testing phase where the complete integrated embedded system is tested as a whole to verify that it meets all specified requirements and functions correctly in its intended environment."
                },
                {
                    question: "Choose the statement that is false for hardware-based debuggers like JTAG.",
                    options: [
                        "Ability to observe software execution in real time",
                        "Communicates with the debugging computer",
                        "Breakpoint by replacing an instruction in memory with a trap",
                        "Memory and I/O ports are accessible while running"
                    ],
                    correct: 2,
                    explanation: "Hardware-based debuggers like JTAG use hardware breakpoints, not software breakpoints. Software breakpoints work by replacing instructions with trap instructions in memory, but JTAG uses dedicated hardware registers for breakpoints, allowing the original code to remain unchanged."
                },
                {
                    question: "Sort the following technique from the least intrusive (#1) to the most intrusive (#4).",
                    options: [
                        "LED monitoring, Print statements, Hardware Breakpoints, Desk-checking",
                        "Desk-checking, Hardware Breakpoints, LED monitoring, Print statements",
                        "Print statements, LED monitoring, Desk-checking, Hardware Breakpoints",
                        "Hardware Breakpoints, Desk-checking, Print statements, LED monitoring"
                    ],
                    correct: 1,
                    explanation: "When ranked by the amount of code or hardware modification required, the order from least to most intrusive is: Desk-checking (no code changes), Hardware Breakpoints (uses built-in processor registers without altering code), LED monitoring (requires additional hardware wiring), and Print statements (modifies source code and affects timing)."
                },
                {
                    question: "What does 'Firmware' refer to in the context of embedded systems?",
                    options: [
                        "Software that controls hardware devices",
                        "Hardware components of the system",
                        "User interface elements",
                        "Networking protocols"
                    ],
                    correct: 0,
                    explanation: "Firmware is specialized software that is programmed into the non-volatile memory of an embedded system to control and manage hardware devices. It provides low-level control and serves as the interface between hardware and higher-level software."
                },
                {
                    question: "Which statement about coding errors is true for a typical software project",
                    options: [
                        "Good programmers don't write code with errors",
                        "You can't find all defects, no matter what",
                        "Good software engineering practices mean no errors in code",
                        "Careful testing is needed to remove all errors"
                    ],
                    correct: 1,
                    explanation: "It is a fundamental principle in software engineering that you cannot find all defects regardless of the testing effort. Even with the best practices and thorough testing, some defects may remain undetected. This is why software development focuses on minimizing defects rather than claiming to eliminate them all."
                },
                {
                    question: "In embedded systems, what does 'real-time testing' refer to?",
                    options: [
                        "Testing conducted under laboratory conditions",
                        "Testing conducted by real users",
                        "Testing conducted using real hardware components",
                        "Testing that assesses the system's ability to respond within a specific time frame"
                    ],
                    correct: 3,
                    explanation: "Real-time testing in embedded systems refers to testing the system's ability to meet timing constraints and respond to events within specified time deadlines. This ensures the system can handle time-critical operations as required by real-time applications."
                },
                {
                    question: "What is the primary goal of regression testing in embedded systems?",
                    options: [
                        "To identify and fix security vulnerabilities",
                        "To validate hardware components",
                        "To test new features and functionality",
                        "To ensure that new changes do not introduce defects into existing functionality"
                    ],
                    correct: 3,
                    explanation: "Regression testing aims to verify that recent code changes, bug fixes, or new features have not adversely affected existing functionality. It ensures system stability by catching unintended side effects of modifications."
                },
                {
                    question: "What is the purpose of black-box testing in embedded systems?",
                    options: [
                        "Testing hardware components",
                        "None of the above",
                        "Testing the internal structure of the software",
                        "Testing the functionality of the software without knowledge of its internal implementation"
                    ],
                    correct: 3,
                    explanation: "Black-box testing is a testing technique that examines the functionality of software without knowledge of its internal structure, implementation, or code. Testers focus on inputs and outputs, treating the system as a 'black box'."
                },
                {
                    question: "Which testing technique involves feeding predefined inputs into the system and comparing the actual outputs with expected outputs?",
                    options: [
                        "Black-box testing",
                        "Functional testing",
                        "Stress testing",
                        "White-box testing"
                    ],
                    correct: 0,
                    explanation: "Black-box testing involves testing inputs and outputs without knowledge of internal implementation. The tester feeds predefined inputs into the system and compares actual outputs with expected outputs to validate functionality."
                },
                {
                    question: "For black box testing a unit under test (UUT), which of the following is true?",
                    options: [
                        "The test should contain all possible input values",
                        "The UUE internal behaviour needs to be examined",
                        "The UUE internal behaviour is not a concern",
                        "Test values should be designed to match the code inside the UUE"
                    ],
                    correct: 2,
                    explanation: "In black-box testing, the internal behavior of the Unit Under Evaluation (UUE) is not a concern. The focus is solely on testing the external behavior by examining inputs and outputs without considering the internal implementation or code structure."
                },
                {
                    question: "Which aspect is the MOST important when performing debugging? (Select 2)",
                    options: [
                        "stabilization",
                        "performance",
                        "intrusiveness",
                        "optimization"
                    ],
                    correct: [2, 0],
                    explanation: "The most important aspects when debugging are intrusiveness (how much the debugging method interferes with normal system operation) and stabilization (ensuring the system remains stable during debugging). Minimizing intrusiveness helps maintain real-time behavior, while stabilization ensures reliable and reproducible debugging sessions.",
                    multipleCorrect: true
                },
                {
                    question: "What is the primary goal of code coverage analysis in embedded software testing?",
                    options: [
                        "Assessing system performance",
                        "Evaluating the completeness of test cases",
                        "Analyzing hardware components",
                        "Measuring the efficiency of code execution"
                    ],
                    correct: 1,
                    explanation: "Code coverage analysis measures the extent to which the source code has been executed during testing. Its primary goal is to evaluate the completeness of test cases by identifying which parts of the code have been tested and which parts remain untested, helping ensure thorough testing."
                },
                {
                    question: "JTAG can support which of the following (select all that apply):",
                    options: [
                        "Simulate code running in a virtual sandbox",
                        "Examine the contents of memory and program FLASH",
                        "Allow single-stepping, breakpoints and watchpoints",
                        "Debug the CPU as well as internal peripherals"
                    ],
                    correct: [1, 2, 3],
                    explanation: "JTAG (Joint Test Action Group) is a hardware debugging interface that allows examination of memory and FLASH contents, supports single-stepping, breakpoints, and watchpoints, and can debug both the CPU and internal peripherals. However, JTAG works with real hardware, not virtual sandboxes.",
                    multipleCorrect: true
                },
                {
                    question: "Test cases contain a definition of which of the following (select all that apply):",
                    options: [
                        "Expected behaviour",
                        "Wanted output",
                        "Actual behaviour",
                        "Only correct input values"
                    ],
                    correct: [0, 1],
                    explanation: "A complete test case definition includes the expected behavior (what should happen), the wanted output (desired results), and the actual behavior (what actually happens during testing). Test cases should include various input values, not just correct ones, to test edge cases and error handling.",
                    multipleCorrect: true
                },
                {
                    question: "Which testing technique focuses on testing the interactions between various software modules or components?",
                    options: [
                        "Unit testing",
                        "System testing",
                        "Integration testing",
                        "Stress testing"
                    ],
                    correct: 2,
                    explanation: "Integration testing specifically focuses on testing the interactions and interfaces between different software modules or components after they have been individually tested. It verifies that combined modules work together correctly."
                },
                {
                    question: "Which debugging technique would be the most appropriate for an ISR interrupt sub routine?",
                    options: [
                        "hardware breakpoints",
                        "software breakpoints",
                        "LED monitoring",
                        "print statement"
                    ],
                    correct: 0,
                    explanation: "Hardware breakpoints are the most appropriate for debugging ISR (Interrupt Service Routine) because they are non-intrusive and don't alter timing behavior. Software breakpoints, print statements, and LED monitoring can introduce timing delays that may affect interrupt handling and mask timing-related bugs."
                },
                {
                    question: "Which techniques are the most appropriate tool for measuring the timing of an interrupt. (choose 2)",
                    options: [
                        "Hardware timer unit",
                        "GPIO + Oscilloscope",
                        "API to call the OS Clock",
                        "printf Statements"
                    ],
                    correct: [0, 1],
                    explanation: "Hardware timer units provide precise timing measurements without software overhead. GPIO pins toggled in the ISR and monitored with an oscilloscope allow external, non-intrusive timing measurement. OS Clock APIs and printf statements introduce significant timing overhead and are unsuitable for accurate interrupt timing measurements.",
                    multipleCorrect: true
                }
            ],
            sensor: [
                {
                    question: "Raspberry Pi's GPIO pins can support which of the following:",
                    options: ["Analogue output only", "Digital input and output", "Analogue and digital input and output", "Analogue input and digital output"],
                    correct: 1,
                    explanation: "The Raspberry Pi GPIO pins only support digital input and output. They do not natively support analogue functionality; external ADCs or DACs are required for analogue signals."
                },
                {
                    question: "A typical sensor will perform signal conditioning before sending out the signal in a digital format. Which of the following does not occur within a sensor module?",
                    options: ["Digital-to-Analog Convertor", "Amplification", "Analog-to-Digital Convertor", "Control logic"],
                    correct: 0,
                    explanation: "Typical sensor modules perform amplification, control logic, and analog-to-digital conversion before outputting digital signals. Digital-to-Analog conversion is not performed within a sensor module preparing a signal for microcontroller input."
                },
                {
                    question: "Which of the following is not typically used to detect change in a sensor?",
                    image: "conductive.jpg",
                    options: ["Area of conductive plates", "Material of dielectric", "Distance between conductive plates", "Material of conductive plates"],
                    correct: 3,
                    explanation: "Capacitive sensors detect change using area, dielectric material, and distance between plates. The material of the conductive plates is generally not a changing or detected variable."
                },
                {
                    question: "Which of the following is NOT a stimulus.",
                    options: ["Pressure", "Sound", "Displacement", "Contempt"],
                    correct: 3,
                    explanation: "Contempt is an emotion and not a measurable physical stimulus; sensors respond to stimuli like pressure, sound, or displacement."
                },
                {
                    question: "Which of the following is not part of a Servo Motor (e.g. SG90)?",
                    options: ["motor", "inductor", "potentiometer", "microcontroller"],
                    correct: 1,
                    explanation: "Standard servo motors like the SG90 include a motor, gear, potentiometer for position, and microcontroller for controlâ€”but not an inductor."
                },
                {
                    question: "The following sensor uses capacitance to detect water level. Which change in factor are we trying to detect?",
                    image: "sensor.jpg",
                    options: ["Distance between Dielectric", "Area of conductive plates", "Distance between conductive plates", "Material of conductive plates."],
                    correct: 1,
                    explanation: "Capacitive water level sensors detect changes in the area of the conductive plates that are immersed in the water, affecting the measurable capacitance."
                },
                {
                    question: "Select the statement that is true for the logic interface for these devices. ",
                    image: "device.png",
                    options: [
                        '"Raspberry Pi GPIO" can be an Output and "Sensor Pin" can be an Input',
                        '"Raspberry Pi GPIO" can be an Input and "Sensor Pin" can be an Output',
                        'Both these devices cannot "talk" to each other.',
                        'Both "Raspberry Pi GPIO" and "Sensor Pin" can be an Input and Output'
                    ],
                    correct: 0,
                    explanation: "For typical embedded sensor interfacing, the Raspberry Pi GPIO may output a signal (control or power), and the sensor pin may act as input, receiving that signal."
                },
                {
                    question: "A __________ is a device that converts energy from one form to another. Usually a __________ converts a signal in one form of energy to a signal in another. (Choose the best answer)",
                    options: ["transducer, transducer", "transformer, transducer", "convertor, transducer", "thermophile, thermometer"],
                    correct: 0,
                    explanation: "A transducer converts energy between forms, and also converts signals between different forms of energy, making both blanks 'transducer' in the classic technical definition."
                },
                {
                    question: "A sensor is a device that receives a stimulus and responds with an electrical signal. Electrical here means a signal that can be channeled, amplified, and modified by electronic devices. Which of the following is NOT a type of response that the microcontroller can handle?",
                    options: ["Acceleration", "Induction", "Power", "Charge"],
                    correct: 0,
                    explanation: "Microcontrollers typically handle voltage, current, charge, and induction as signal types. Acceleration is a physical quantity measured by sensors; the microcontroller does not directly process 'acceleration signals.'"
                }
            ],
            adc: [
                {
                    question: "Quantization process is generally __________ and results in information __________ .",
                    options: [
                        "irreversible, loss",
                        "reversible, loss",
                        "irreversible, gain",
                        "reversible, gain"
                    ],
                    correct: 0,
                    explanation: "Quantization is irreversible and results in information loss since continuous signals are mapped to discrete levels."
                },
                {
                    question: "A signal that ranges from 0v to 3.3v is fed into a 7-bit ADC. What is the representation of sampled analog voltage of 0.12V? (Assume the error is between 0 to 1 least significant bit)",
                    options: [
                        "000 0110b",
                        "0x04",
                        "001 0010b",
                        "0x12"
                    ],
                    correct: 1,
                    explanation: "For a 7-bit ADC, resolution = 3.3V / 2â· = 0.02578V per step. 0.12V / 0.02578 â‰ˆ 4.65 â†’ round to 4 (0x04)."
                },
                {
                    question: "Select which of the following occurs within an ADC (tick all that apply):",
                    options: [
                        "Transduction",
                        "Quantisation",
                        "Sampling",
                        "Inversion"
                    ],
                    correct: [1, 2],
                    multipleCorrect: true,
                    explanation: "An ADC performs Sampling (discretizing in time) and Quantisation (discretizing in amplitude). Transduction happens in sensors before the ADC."
                },
                {
                    question: "An ADC should quantise a continuous signal differently to how it quantises a single value.",
                    options: ["True", "False"],
                    correct: 1,
                    explanation: "False. Quantisation works the same way regardless of whether the signal is continuous or a single measurement."
                },
                {
                    question: "When referring to an ADC, quantisation means",
                    options: [
                        "The number of discrete levels used to represent a sample",
                        "The sample rate at which a sample is converted to digital",
                        "The sample is converted to analogue by a DAC",
                        "The biggest (maximum) value that the sample can reach"
                    ],
                    correct: 0,
                    explanation: "Quantisation refers to dividing the range of an analog signal into discrete digital levels for representation."
                },
                {
                    question: "A transducer",
                    options: [
                        "Converts a signal from one form into another",
                        "Always crosses between analogue and digital domains",
                        "Is a digital device used to measure voltage",
                        "Channels the energy emitted by the Tesseract"
                    ],
                    correct: 0,
                    explanation: "A transducer converts one form of energy or signal into anotherâ€”e.g., sound to voltage."
                },
                {
                    question: "If an input signal to an ADC raises slightly above Vref, then it is",
                    options: [
                        "Clipped",
                        "Measured as a 0",
                        "Destroyed",
                        "Ignored until the voltage drops below Vref"
                    ],
                    correct: 0,
                    explanation: "Any voltage above the reference voltage (Vref) saturates at the maximum digital outputâ€”this is called clipping."
                },
                {
                    question: "What is the typical sample rate and data size of a CD-quality audio signal?",
                    options: [
                        "20-bits and 24kHz",
                        "8-bits and 48kHz",
                        "256kHz and 32-bits",
                        "44.1kHz and 16-bits"
                    ],
                    correct: 3,
                    explanation: "CD-quality audio uses 44.1 kHz sampling rate and 16-bit resolution per channel."
                },
                {
                    question: "Nyquist's theorem states that perfect reconstruction may be possible if the signal is sampled how fast?",
                    options: [
                        "At least 2x faster than the highest frequency component",
                        "As fast as the ADC can sample",
                        "At least 48kHz",
                        "With at least 2x as many bits as the signal should have"
                    ],
                    correct: 0,
                    explanation: "Nyquistâ€™s theorem states the sampling rate must be at least twice the highest frequency in the signal for accurate reconstruction."
                }
            ],


        };

        let currentTopic = 'welcome';
        let userAnswers = {};
        let showingAnswers = false;
        let shuffledQuestions = {};

        // Shuffle array function
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Shuffle options while tracking correct answer
        function shuffleQuestionOptions(question) {
            if (question.type === 'fill' || !Array.isArray(question.options)) {
                return { ...question };
            }

            const shuffled = { ...question };
            const optionsWithIndices = question.options.map((opt, idx) => ({ text: opt, originalIndex: idx }));
            const shuffledOptions = shuffleArray(optionsWithIndices);

            shuffled.options = shuffledOptions.map(opt => opt.text);

            if (Array.isArray(question.correct)) {
                shuffled.correct = question.correct.map(correctIdx =>
                    shuffledOptions.findIndex(opt => opt.originalIndex === correctIdx)
                );
            } else {
                shuffled.correct = shuffledOptions.findIndex(opt => opt.originalIndex === question.correct);
            }

            return shuffled;
        }

        function renderQuiz(topic) {
            const container = document.getElementById(topic);
            if (!questions[topic]) return;

            const questionsArray = shuffledQuestions[topic] || questions[topic];

            // initialize userAnswers for this topic
            userAnswers[topic] = questionsArray.map(q => q.type === 'fill' ? new Array((q.answers?.length || 1)).fill('') : null);

            let html = `
                <div class="controls">
                    <button class="btn btn-primary" onclick="checkAnswers('${topic}')">Submit Answers</button>
                    <button class="btn btn-secondary" onclick="resetQuiz('${topic}')">Reset</button>
                    <button class="btn btn-secondary" onclick="toggleAnswers('${topic}')">Toggle All Answers</button>
                    <button class="btn btn-shuffle" onclick="shuffleQuiz('${topic}')">ðŸ”€ Shuffle Questions</button>
                </div>
                <div class="score-display" id="score-${topic}" style="display: none;"></div>
            `;

            questionsArray.forEach((q, index) => {
                const imageHTML = q.image ? `<img src="${q.image}" alt="Question diagram" style="max-width: 100%; max-height: 400px; margin: 15px 0; border-radius: 8px; display: block;">` : '';

                // Build options area (MCQ vs FILL)
                let optionsHTML = '';
                if (q.type === 'fill') {
                    const blanks = q.answers?.length || 1;
                    const inputs = Array.from({ length: blanks }, (_, i) => `
                        <input class="fill-input" 
                            id="fill-${topic}-${index}-${i}"
                            type="text" 
                            placeholder="Answer ${i + 1}" 
                            oninput="recordFill('${topic}', ${index}, ${i}, this.value)">
                    `).join('');
                    optionsHTML = `<div class="fill-inputs">${inputs}</div>`;
                } else {
                    optionsHTML = `
                        <div class="options">
                            ${q.options.map((option, optIndex) => `
                                <div class="option" onclick="selectOption('${topic}', ${index}, ${optIndex}, ${q.multipleCorrect || false})">
                                    <input type="${q.multipleCorrect ? 'checkbox' : 'radio'}" 
                                        name="q${topic}-${index}" 
                                        id="q${topic}-${index}-${optIndex}"
                                        style="margin-right: 10px;">
                                    <label for="q${topic}-${index}-${optIndex}" style="cursor: pointer;">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                const answerText = q.type === 'fill'
                    ? q.answers.join(', ')
                    : (Array.isArray(q.correct) ? q.correct.map(i => q.options[i]).join(', ') : q.options[q.correct]);

                html += `
                    <div class="question-card">
                        <div class="question-header">
                            <span class="question-number">Question ${index + 1}</span>
                            ${q.multipleCorrect ? '<span class="question-number" style="background: #ff9800;">Multiple Answers</span>' : ''}
                        </div>
                        <div class="question-text">${q.question}</div>
                        ${imageHTML}
                        ${optionsHTML}
                        <div class="answer-section" id="answer-${topic}-${index}">
                            <div class="answer-label">Correct Answer: ${answerText}</div>
                            <div class="explanation">${q.explanation || ''}</div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function recordFill(topic, qIndex, blankIndex, value) {
            if (!Array.isArray(userAnswers[topic][qIndex])) {
                userAnswers[topic][qIndex] = [];
            }
            userAnswers[topic][qIndex][blankIndex] = value;
        }

        // 2) Topic-level shuffle that respects fill-in questions
        function shuffleQuiz(topic) {
            // Shuffle question order
            const shuffledQuestionsArray = shuffleArray(questions[topic]);

            // Shuffle options only for MCQs
            shuffledQuestions[topic] = shuffledQuestionsArray.map(q =>
                (q.type === 'fill' ? { ...q } : shuffleQuestionOptions(q))
            );

            // Re-render + reset
            renderQuiz(topic);
            showingAnswers = false;
        }


        function renderAllTopics() {
            const container = document.getElementById('all');
            const allQuestions = [];

            Object.keys(questions).forEach(topic => {
                questions[topic].forEach((q, index) => {
                    allQuestions.push({...q, topic, originalIndex: index});
                });
            });

            const shuffled = shuffleArray(allQuestions);
            const finalShuffled = shuffled.map(q => {
                if (q.type === 'fill') return q; // no option shuffling needed
                const shuffledQ = shuffleQuestionOptions(q);
                shuffledQ.topic = q.topic;
                shuffledQ.originalIndex = q.originalIndex;
                return shuffledQ;
            });

            userAnswers['all'] = finalShuffled.map(q => q.type === 'fill' ? new Array((q.answers?.length || 1)).fill('') : null);

            let html = `
                <div class="controls">
                    <button class="btn btn-primary" onclick="checkAnswers('all')">Submit Answers</button>
                    <button class="btn btn-secondary" onclick="resetQuiz('all')">Reset</button>
                    <button class="btn btn-secondary" onclick="toggleAnswers('all')">Toggle All Answers</button>
                    <button class="btn btn-shuffle" onclick="reshuffleAllTopics()">ðŸ”€ Shuffle Questions</button>
                </div>
                <div class="score-display" id="score-all" style="display: none;"></div>
            `;

            finalShuffled.forEach((q, index) => {
                let optionsHTML = '';
                if (q.type === 'fill') {
                    const blanks = q.answers?.length || 1;
                    const inputs = Array.from({ length: blanks }, (_, i) => `
                        <input class="fill-input" 
                            id="fill-all-${index}-${i}"
                            type="text" 
                            placeholder="Answer ${i + 1}" 
                            oninput="recordFill('all', ${index}, ${i}, this.value)">
                    `).join('');
                    optionsHTML = `<div class="fill-inputs">${inputs}</div>`;
                } else {
                    optionsHTML = `
                        <div class="options">
                            ${q.options.map((option, optIndex) => `
                                <div class="option" onclick="selectOption('all', ${index}, ${optIndex}, ${q.multipleCorrect || false})">
                                    <input type="${q.multipleCorrect ? 'checkbox' : 'radio'}" 
                                        name="q-all-${index}" 
                                        id="q-all-${index}-${optIndex}"
                                        style="margin-right: 10px;">
                                    <label for="q-all-${index}-${optIndex}" style="cursor: pointer;">${option}</label>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                const answerText = q.type === 'fill'
                    ? q.answers.join(', ')
                    : (Array.isArray(q.correct) ? q.options[q.correct[0]] : q.options[q.correct]);

                html += `
                    <div class="question-card">
                        <div class="question-header">
                            <span class="question-number">Question ${index + 1}</span>
                            <span class="question-number" style="background: #764ba2;">${q.topic.toUpperCase()}</span>
                            ${q.multipleCorrect ? '<span class="question-number" style="background: #ff9800;">Multiple Answers</span>' : ''}
                        </div>
                        <div class="question-text">${q.question}</div>
                        ${optionsHTML}
                        <div class="answer-section" id="answer-all-${index}">
                            <div class="answer-label">Correct Answer: ${q.type === 'fill'
                                ? q.answers.join(', ')
                                : (Array.isArray(q.correct) ? q.correct.map(i => q.options[i]).join(', ') : q.options[q.correct])}
                            </div>
                            <div class="explanation">${q.explanation || ''}</div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
            container.dataset.questions = JSON.stringify(finalShuffled);
        }


        function reshuffleAllTopics() {
            renderAllTopics();
            showingAnswers = false;
        }

        function selectOption(topic, questionIndex, optionIndex, isMultiple) {
            const checkbox = document.getElementById(`q${topic === 'all' ? '-all' : topic}-${questionIndex}-${optionIndex}`);
            
            if (isMultiple) {
                checkbox.checked = !checkbox.checked;
                
                if (!Array.isArray(userAnswers[topic][questionIndex])) {
                    userAnswers[topic][questionIndex] = [];
                }
                
                if (checkbox.checked) {
                    if (!userAnswers[topic][questionIndex].includes(optionIndex)) {
                        userAnswers[topic][questionIndex].push(optionIndex);
                    }
                } else {
                    userAnswers[topic][questionIndex] = userAnswers[topic][questionIndex].filter(i => i !== optionIndex);
                }
            } else {
                const allOptions = document.querySelectorAll(`input[name="q${topic === 'all' ? '-all' : topic}-${questionIndex}"]`);
                allOptions.forEach(opt => {
                    opt.checked = false;
                    opt.parentElement.classList.remove('selected');
                });
                
                checkbox.checked = true;
                checkbox.parentElement.classList.add('selected');
                userAnswers[topic][questionIndex] = optionIndex;
            }
        }

        function checkAnswers(topic) {
            const questionsArray = topic === 'all' 
                ? JSON.parse(document.getElementById('all').dataset.questions)
                : (shuffledQuestions[topic] || questions[topic]);

            let correct = 0;
            const total = questionsArray.length;

            questionsArray.forEach((q, index) => {
                let isCorrect = false;

                if (q.type === 'fill') {
                    const given = (userAnswers[topic][index] || []).map(s => (s || '').trim().toLowerCase());
                    const expected = (q.answers || []).map(s => s.trim().toLowerCase());
                    // exact positional match
                    isCorrect = (given.length === expected.length) && given.every((g, i) => g === expected[i]);

                    // color inputs
                    expected.forEach((_, i) => {
                        const el = document.getElementById(`fill-${topic}-${index}-${i}`);
                        if (!el) return;
                        el.classList.remove('correct', 'incorrect');
                        if ((given[i] || '') === expected[i]) el.classList.add('correct');
                        else el.classList.add('incorrect');
                    });
                } else {
                    const userAnswer = userAnswers[topic][index];
                    const correctAnswer = q.correct;
                    if (Array.isArray(correctAnswer)) {
                        isCorrect = Array.isArray(userAnswer) && 
                                    userAnswer.length === correctAnswer.length &&
                                    userAnswer.every(ans => correctAnswer.includes(ans));
                    } else {
                        isCorrect = userAnswer === correctAnswer;
                    }

                    // decorate MCQ options
                    const inputs = document.querySelectorAll(`input[name="q${topic === 'all' ? '-all' : topic}-${index}"]`);
                    inputs.forEach((input, optIndex) => {
                        const optionDiv = input.parentElement;
                        optionDiv.classList.remove('correct', 'incorrect');

                        if (Array.isArray(q.correct)) {
                            if (q.correct.includes(optIndex)) {
                                optionDiv.classList.add('correct');
                            } else if (Array.isArray(userAnswers[topic][index]) && userAnswers[topic][index].includes(optIndex)) {
                                optionDiv.classList.add('incorrect');
                            }
                        } else {
                            if (optIndex === q.correct) {
                                optionDiv.classList.add('correct');
                            } else if (optIndex === userAnswers[topic][index]) {
                                optionDiv.classList.add('incorrect');
                            }
                        }
                    });
                }

                if (isCorrect) correct++;
                document.getElementById(`answer-${topic}-${index}`).classList.add('show');
            });

            const scoreDisplay = document.getElementById(`score-${topic}`);
            const percentage = ((correct / total) * 100).toFixed(1);
            scoreDisplay.innerHTML = `
                Score: ${correct} / ${total} (${percentage}%)
                ${percentage >= 80 ? 'ðŸŽ‰ Excellent!' : percentage >= 60 ? 'ðŸ‘ Good job!' : 'ðŸ’ª Keep practicing!'}
            `;
            scoreDisplay.style.display = 'block';
            showingAnswers = true;
        }


        function resetQuiz(topic) {
            const questionsArray = topic === 'all' 
                ? JSON.parse(document.getElementById('all').dataset.questions)
                : (shuffledQuestions[topic] || questions[topic]);

            userAnswers[topic] = questionsArray.map(q => q.type === 'fill' ? new Array((q.answers?.length || 1)).fill('') : null);

            questionsArray.forEach((q, index) => {
                if (q.type === 'fill') {
                    const blanks = q.answers?.length || 1;
                    for (let i = 0; i < blanks; i++) {
                        const el = document.getElementById(`fill-${topic}-${index}-${i}`);
                        if (el) {
                            el.value = '';
                            el.classList.remove('correct', 'incorrect');
                        }
                        const elAll = document.getElementById(`fill-all-${index}-${i}`);
                        if (elAll) {
                            elAll.value = '';
                            elAll.classList.remove('correct', 'incorrect');
                        }
                    }
                } else {
                    const optionDivs = document.querySelectorAll(`input[name="q${topic === 'all' ? '-all' : topic}-${index}"]`);
                    optionDivs.forEach(input => {
                        input.checked = false;
                        input.parentElement.classList.remove('selected', 'correct', 'incorrect');
                    });
                }

                const ansId = `answer-${topic}-${index}`;
                const ans = document.getElementById(ansId);
                if (ans) ans.classList.remove('show');
            });

            const scoreDisplay = document.getElementById(`score-${topic}`);
            if (scoreDisplay) scoreDisplay.style.display = 'none';

            showingAnswers = false;
        }


        function toggleAnswers(topic) {
            const questionsArray = topic === 'all' 
                ? JSON.parse(document.getElementById('all').dataset.questions)
                : (shuffledQuestions[topic] || questions[topic]);
            
            showingAnswers = !showingAnswers;
            
            questionsArray.forEach((q, index) => {
                const answerSection = document.getElementById(`answer-${topic}-${index}`);
                if (showingAnswers) {
                    answerSection.classList.add('show');
                } else {
                    answerSection.classList.remove('show');
                }
            });
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const topic = this.dataset.topic;
                
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                document.querySelectorAll('.quiz-mode').forEach(mode => mode.classList.remove('active'));
                document.getElementById(topic).classList.add('active');
                
                currentTopic = topic;
                showingAnswers = false;
            });
        });

        // Initialize quizzes
        renderQuiz('intro');
        renderQuiz('c');
        renderQuiz('gpio');
        renderQuiz('digital');
        renderQuiz('interrupts'); 
        renderQuiz('timers');
	renderQuiz('adc');        // <-- Add this line
        renderQuiz('os');
        renderQuiz('testing');
        renderQuiz('optimise');
        renderQuiz('sensor');
        renderAllTopics();
    </script>
</body>
</html>